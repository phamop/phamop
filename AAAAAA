<#
.DESCRIPTION
    Adds new Secrets or Removes/Soft-Deletes existing secrets based on the availability and value of the current secret

#>
function Update-AzKeyVaultSecretV2 {
    param(
        [Parameter(Mandatory)]
        [string]$VaultName,

        [Parameter(Mandatory)]
        [string]$SecretName,

        [Parameter(Mandatory)]
        [string]$SecretValue,

        [Parameter()]
        [bool]$OverwriteExisting = $false
    )

    $updateSecret = $true
    Write-Verbose "Fetching existing secret ($SecretName)"
    $existing = Get-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -AsPlainText
    if ($existing) {
        # if it's different or overwrite flag is present
        if (($existing -ne $SecretValue) -or $OverwriteExisting) {

            # TODO: Revisit this logic...
            #    Shouldn't we be keeping older versions of the secret if SoftDelete isn't enabled?
            #    SoftDelete allows secrets to be recovered if they're deleted.    
            if ((Get-AzKeyVault -VaultName $VaultName).EnableSoftDelete) {
                Write-Verbose "Soft delete: Marking previous secret ($SecretName) as disabled"
                Update-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -Enable $false -ErrorAction SilentlyContinue
            }
            else {
                Write-Verbose "Hard delete: Removing existing secret ($SecretName)"
                $null = Remove-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -PassThru -Force -ErrorAction SilentlyContinue
            }
        } else {
            # don't update the secret because it hasn't changed and we're not overwriting
            Write-Host "Skipping secret '$SecretName' because the current value is already present in KeyVault '$VaultName'"
            $updateSecret = $false
        }
    }

    if ($updateSecret) {
        Write-Verbose "Adding secret $SecretName"
        $secureSecret = $SecretValue | ConvertTo-SecureString -AsPlainText -Force
        $null = Set-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -SecretValue $secureSecret
        Write-Host "Added secret '$SecretName' to Key Vault '$VaultName'."
        Write-Output $SecretName
    }
}

<#
.DESCRIPTION
    Evaulates if a secret exists in a key vault
#>
function Test-AzKeyVaultSecretV2 {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$VaultName,

        [Parameter(Mandatory)]
        [string]$SecretName
    )

    if (Get-AzKeyVaultSecret -VaultName $VaultName -Name $SecretName -AsPlainText) {
        return $true
    } else {
        return $false
    }
}


<#
.SYNOPSIS
Imports a certificate and private key to the indicated Key Vault.

.DESCRIPTION
Imports a certificate and private key to the indicated Key Vault.  If the certificate already exists, a new version
will be created.

.PARAMETER VaultName
The name of the Key Vault.

.PARAMETER VaultCertificateName
The name of the certificate for use when importing to Key Vault.

.PARAMETER CertificatePath
The path to the certificate file.  At the time of this writing, PEM files cannot be directly uploaded
using the Import-AzKeyVaultCertificate cmdlet.  Reference: https://github.com/MicrosoftDocs/azure-docs/issues/16543.
Instead, this function will combine the certificate and private key file to a PFX keystore, set a temporary
passphrase, then upload the PFX.

.PARAMETER PrivateKeyPath
The path to the private key file.  At the time of this writing, PEM files cannot be directly uploaded
using the Import-AzKeyVaultCertificate cmdlet.  Reference: https://github.com/MicrosoftDocs/azure-docs/issues/16543.
Instead, this function will combine the certificate and private key file to a PFX keystore, set a temporary
passphrase, then upload the PFX.
#>
function Import-AzKeyVaultCertificateV2 {
    param(
        [Parameter(Mandatory = $true)]
        [string]
        $VaultName,

        [Parameter(Mandatory = $true)]
        [string]
        $VaultCertificateName,

        [Parameter(Mandatory = $true)]
        [string]
        $CertificatePath,

        [Parameter(Mandatory = $true)]
        [string]
        $PrivateKeyPath
    )

    # Terminates the script on an error action.
    $ErrorActionPreference = "Stop"

    $keystorePath = $PrivateKeyPath.Replace(".key", ".pfx")
    $keystorePassphrase = "Password1"

    # Uncomment the block below for troubleshooting purposes.
    Write-Output $("-" * 125)
    Write-Output "Importing a certificate to Key Vault with these settings:`n"
    Write-Output "`tKey Vault Name:              $VaultName"
    Write-Output "`tKey Vault Certificate Name:  $VaultCertificateName"
    Write-Output "`tCertificate Path:            $CertificatePath"
    Write-Output "`tPrivate Key Path:            $PrivateKeyPath"
    Write-Output $("-" * 125)

    # Combine the certificate and private key to a PFX and add a passphrase.
    # At the time of this writing, PEM files cannot be uploaded to Azure Key Vault via Azure CLI or Azure PowerShell.
    # Only PKCS #12 (PFX) keystores are supported and must be secured with a passphrase.  References:
    #   https://github.com/MicrosoftDocs/azure-docs/issues/23558#issuecomment-460485031
    #   https://github.com/MicrosoftDocs/azure-docs/issues/16543
    openssl pkcs12 `
        -export -inkey "$PrivateKeyPath" -in "$CertificatePath" `
        -out $keystorePath -passout pass:"$keystorePassphrase"

    # Import the new PFX keystore to Key Vault.
    $secureKeystorePassphrase = ConvertTo-SecureString "$keystorePassphrase" -AsPlainText -Force
    $null = Import-AzKeyVaultCertificate -VaultName $VaultName -Name $VaultCertificateName -FilePath $keystorePath -Password $secureKeystorePassphrase
    Write-Output "*** Imported Certificate ($VaultCertificateName) to Key Vault ($VaultName) from $keystorePath."
}


<#
.SYNOPSIS
Downloads a certificate from the indicated Key Vault.

.DESCRIPTION
Downloads a certificate from the indicated Key Vault.  A PKCS #12 (PFX) keystore and the public certificate
file will be generated.  Use the one appropriate for your needs.  These files should be deleted when done
due to the security risks.

.PARAMETER VaultName
The name of the Key Vault.

.PARAMETER VaultCertificateName
The name of the certificate to download.

.PARAMETER CertificatePath
The path to save the downloaded certificate file.

.PARAMETER CertificatePasspharse
The passpharse to set for the PKCS #12 (PFX) keystore.  This parameter is optional as the passphrase is
temporary.  Upon uploading to Azure resources (e.g., Key Vault, APIM), the passphrase is stripped in any case.

.PARAMETER CertificateThumbprintVariableName
The name of the variable to use for setting the certificate thumbprint value.  This parameter is optional as
the thumbprint is not always needed downstream.

.NOTES
Most of the code below is from Microsoft Docs for Get-AzKeyVaultCertificate:
- https://docs.microsoft.com/en-us/powershell/module/az.keyvault/get-azkeyvaultcertificate?view=azps-5.0.0#example-2--get-cert-and-save-it-as-pfx
#>
function Get-AzKeyVaultCertificateV2 {
    param(
        [Parameter(Mandatory = $true)]
        [string]
        $VaultName,

        [Parameter(Mandatory = $true)]
        [string]
        $VaultCertificateName,

        [Parameter(Mandatory = $true)]
        [string]
        $CertificatePath,

        [Parameter(Mandatory = $false)]
        [System.Security.SecureString]
        $CertificatePassphrase = $(ConvertTo-SecureString "Password1" -AsPlainText -Force),

        [Parameter(Mandatory = $false)]
        [string]
        $CertificateThumbprintVariableName
    )

    # Terminates the script on an error action.
    $ErrorActionPreference = "Stop"

    # Uncomment the block below for troubleshooting purposes.
    # Write-Output $("-" * 125)
    # Write-Output "Downloading a certificate from Key Vault with these settings:`n"
    # Write-Output "`tKey Vault Name:              $VaultName"
    # Write-Output "`tKey Vault Certificate Name:  $VaultCertificateName"
    # Write-Output "`tCertificate Path:            $CertificatePath"
    # Write-Output $("-" * 125)

    # Download the certificate from Key Vault.
    # Reference: https://docs.microsoft.com/en-us/powershell/module/az.keyvault/get-azkeyvaultcertificate?view=azps-5.0.0#example-2--get-cert-and-save-it-as-pfx
    $cert = Get-AzKeyVaultCertificate -VaultName $VaultName -Name $VaultCertificateName
    Write-Output "My certname: $cert.Name "
    $secret = Get-AzKeyVaultSecret -VaultName $VaultName -Name $cert.Name
     Write-Output "The secret: $secret.SecretValue"
     Write-Output "The certname: $cert.Name "
    $secretValueText = '';
    $ssPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secret.SecretValue)

    try {
        $secretValueText = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ssPtr)
    } finally {
        [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ssPtr)
    }

    $secretBytes = [Convert]::FromBase64String($secretValueText)
    $x509Cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($secretBytes, "", "Exportable,PersistKeySet")

    # Save the keystore to a PFX file.
    $pfxType = [System.Security.Cryptography.X509Certificates.X509ContentType]::Pfx
    $pfxFileBytes = $x509Cert.Export($pfxType, $CertificatePassphrase)

    [System.IO.File]::WriteAllBytes("$CertificatePath/$($VaultCertificateName).pfx", $pfxFileBytes)

    # Save the public certificate to a CER file.
    $cerType = [System.Security.Cryptography.X509Certificates.X509ContentType]::Cert
    $cerFileBytes = $x509Cert.Export($cerType, $CertificatePassphrase)

    [System.IO.File]::WriteAllBytes("$CertificatePath/$($VaultCertificateName).cer", $cerFileBytes)

    # Set the thumbprint of the new certificate to a pipeline variable if the variable name is set.
    if (-not [string]::IsNullOrEmpty("$CertificateThumbprintVariableName")) {
        Write-Output "##vso[task.setvariable variable=$CertificateThumbprintVariableName;]$($x509Cert.Thumbprint)"
    }
}
